
# UDP & TCP速览

<!-- TOC -->

- [UDP协议](#udp协议) <br>
- [TCP协议](#tcp协议) 
	- [1.连接管理](#1连接管理) <br>
		- [1.1 建立连接：三次握手](#11-建立连接三次握手) <br>
		- [1.2 中间传输与反馈过程中的Segment](#12-中间传输与反馈过程中的segment) <br>
		- [1.3 断开连接：四次挥手](#13-断开连接四次挥手) <br>
	- [2.TCP如何实现“可靠”](#2tcp如何实现可靠) <br>
		- [2.1重传](#21重传) <br>
		- [2.2 差错恢复机制](#22-差错恢复机制) <br>
		- [2.3.流量控制](#23流量控制) <br>
	- [3.拥塞控制](#3拥塞控制) <br>
		- [3.1概述](#31概述) <br>
		- [3.2 拥塞控制算法](#32-拥塞控制算法)  <br>
- [常见疑问](#常见疑问) <br>

<!-- /TOC -->


# UDP协议

udp格式:

```
				 0      7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |     Source      |   Destination   |
                 |      Port       |      Port       |
                 +--------+--------+--------+--------+
                 |                 |                 |
                 |     Length      |    Checksum     |
                 +--------+--------+--------+--------+
                 |
                 |          data octets ...
                 +---------------- ...

                      User Datagram Header Format
```

Source Port Destination Port:分别记录源端口、目的端口，与IP协议一起来确定到主机上的socket.

Length:报文段的长度

Checksum:UDP提供端到端的差错检验.

- 无连接状态，无可靠性保证
- 无拥塞控制
- 有差错检验

<br>

# TCP协议

```
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            TCP Header Format
```



**Sequence Number**：序列号. 当SYN=1时，此序列号为连接中TCP的初始序列号.

**Acknowledgment Number**:当ACK位被设置时，此字段为该segment发送者期望接受的下一个segment的**Sequence Number**. 

**ACK**: Acknowledgment field significant  承认标示

**SYN**:Synchronize sequence numbers     同步序列号

**FIN**:No more data from sender

<br>

### 1.连接管理

![](https://ae01.alicdn.com/kf/HTB1At9xMxYaK1RjSZFn76180pXaP.png)


#### 1.1 建立连接：三次握手

第一次 SYN=1 	ACKFlag=0		 	Seq=随机数A 	AckNumber=0

第二次 SYN=1 	ACKFlag=1		 	Seq=随机数B		AckNumber=随机数A+1

第三次 SYN=0 	ACKFlag=1 			Seq=随机数A+1	AckNumber=随机数B+1



#### 1.2 中间传输与反馈过程中的Segment

发送    SYN=0		ACKFlag=0	Seq=随机数A+已发送的字节数	AckNumber=对方上次反馈Segment的Seq+1

反馈    SYN=0		ACKFlag=1	Seq=随机数B+已发送的字节数	AckNumber=对方上次发送Segment的Seq+1

 

#### 1.3 断开连接：四次挥手

1.3.1 主动发起断开：

ESTABLISHED **----发送FIN---->** FIN_WAIT_1 **----收到对方对上个FIN的ACK---->** FIN_WAIT_2 **----收到对方发的FIN,发送对此FIN的ACK---->** TIME_WAIT **----等待2倍IP数据包在网络上可能存活的最大时长---->**CLOSED



1.3.2 被动断开：

ESTABLISHED **----收到对方FIN---->** CLOSE_WAIT **----发送对上个FIN的ACK, 发送自己的FIN---->** LAST_ACK **----收到对方的ACK，关闭 ---->** CLOSED

<br>

### 2.TCP如何实现“可靠”

#### 2.1重传

2.1.1 超时重传

在发送了一个报文段之后，会设置一个定时器。当定时器超时时，即超时还未接收到ACK时，便会触发超时重传。

并且，定时器每次超时时，会将超时时间翻倍。

2.1.2 快速重传

因为超时重传可能会导致等待时间过长，因此还有快速重传机制。

如果TCP接收方收到的报文段并不是等待的报文段，而是超过了等待报文段的序列号，便会触发超时重传机制。会向发送放发送多个冗余ACK，冗余ACK的Ack Number为等待报文段的序列号。

在接受方处，如果连续收到了三个冗余的ACK（即除了平常应该收到的一个，还另外多收到了3个），那么就会触发快速重传，直接发从此报文段给接受方。



#### 2.2 差错恢复机制

失序：

TCP会接收失序的报文段，并缓存起来，等待缺失的报文段到达之后再交给相应的进程。

漏传：

当报文段a没有正确传达，而a-1 a-2 ... a+1 a+2 ... 都成功传达，因此会导致接受方发送3次冗余的ACK，导致发送方快速重传缺失的报文段，并且只会重传a，不会重传a之后的报文段。

#### 2.3.流量控制

TCP保证 LastByteRcvd - LastByteRead <= RcvBuffer. 即不允许缓存溢出。

接收窗口rwnd是根据接受方的缓存情况来动态生成并传递给发送方的。

接受方处，rwnd = RcvBuffer- [LastByteRcvd - LastByteRead]，其为动态变化的。

发送方需要保证 LastByteSent - LastByteAcked <= rwnd。由此便实现了接受方对发送方的流量控制。

<br>

### 3.拥塞控制

#### 3.1概述

拥塞控制三个问题：

**3.1.1 TCP发送方限制发送流量速率的机制是什么？**

TCP发送方额外跟踪一个变量 拥塞窗口cwnd.

发送方须保证 LastByteSent - LastByteAcked <= min { cwnd, rwnd}

通过调节cwnd便可限制发送速率。

**3.1.2 TCP发送方如何感知出现了拥塞？**

当出现了丢包（超时或快速重传）时，便视为出现了拥塞。

**3.1.3 感知到拥塞时，采取何种算法来改变速率？**

概括来讲：

​	1⃣ 丢失报文时，降低TCP的发送速率

​	2⃣ 已发送未确认的报文段 收到 相应的ACK时，增加发送速率

​	3⃣ TCP发送方先增加速率，知道丢报文段时减少速率，之后再次增加，直到丢报文时再次减小.



#### 3.2 拥塞控制算法

拥塞控制算法中存在三个状态，根据不同事件发生在三个状态之间切换。



1⃣ 慢启动状态

MSS：最大分段大小

进入慢启动状态，cwnd设为1个MSS。每收到一个ACK cwnd都会增加一个MSS，这样每过一个RTT，便将cwnd翻倍。

这个状态持续到以下三个事件发生一个时：

- 发生超时丢包事件 ： TCP将ssthresh设置为 cwnd/2，并将cwnd重新设为1MSS，之后重启慢启动

- cwnd==ssthresh时：TCP结束慢启动，进入拥塞避免状态

- 检测到三个冗余ACK时，ssthresh = cwnd/2；cwnd = ssthresh+3MSS，TCP进行一个快速重传，并进入快速恢复状态


2⃣ 拥塞避免状态

此时TCP发送方增加cwnd速度变慢.

每收到一个ACK，cwnd 便加上 MSS * (MSS/cwnd) 

直到以下两个事件发生一个时：

- 发生超时事件：ssthresh = cwnd / 2 ; cwnd = 1MSS ，重新进入慢启动
- 发生三次冗余ACK：ssthresh = cwnd/2；cwnd = ssthresh+3MSS ，快速重传，并进入快速恢复状态



3⃣ 快速恢复状态

在快速恢复状态，之前有进行快速重传，进行完快速重传之后，便设定一个超时定时器。

若：

- 仍然超时： ssthresh = cwnd/2，cwnd = 1MSS ，进入慢启动
- 快速重传的报文段被ACK： 进入拥塞控制阶段


<br>

# 常见疑问

1. UDP和TCP的区别.

   TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、适合传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)，有拥塞控制（会自己限制自己的速度）。

   UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、无拥塞控制（不会自己限制速度）。

2. TCP四次挥手之后为什么要有TIME_WAIT？

   TIME_WAIT等待的是2倍的ip数据报在网络中可存活的最大时间。

   因为在TIME_WAIT之前，发送方给接受方发送了FIN ACK，但是此FIN ACK可能丢报文。因此要等待2倍的时间，看有没有一个重传的FIN传过来（真的丢失了FINACK，对方超时重传FIN）。不等的话，有可能这个FIN会打断新建立的TCP连接。

3. TIME_WAIT有什么问题？

   在高并发短链接的TCP服务器上，当关闭时因为TIME_WAIT时间太长（短链接中，基本上都小于TIME_WAIT等待的时间），会导致很多socket处于TIME_WAIT状态，占用大量资源不释放，影响服务器性能。



   在linux上使用以下命令查看各个状态的TCP连接各有几个:

   ```bash
   netstat -an|awk '/tcp/ {print $6}'|sort|uniq -c
   ```

   此时可以通过设置TCP的快速回收和重用来解决。

   net.ipv4.tcp_tw_reuse = 1;   //重用  表示允许将在TIME_WAIT状态下的socket重用于新的TCP连接

   net.ipv4.tcp_tw_recycle = 1 // 快速回收
   
4. 为什么是三次握手（而不是两次？第三次作用是什么？）

   **第三次握手是为了防止服务端因为之前滞留的 连接建立请求（即第一次握手） 而建立连接。造成资源浪费**

   解释：

   若只有两次握手，那么如果客户端之前曾发过 第一次握手 但是在网络中因为延迟阻塞了，结果在建立连接之后到达了服务器，那么服务器会再创建一个（多余的）连接。 

   采用三次握手的方式，第三次握手才真正建立连接，可以让服务端不建立多余的连接，节省资源。

   此时，即便客户端发的第一次握手请求被延迟发送到了服务端，服务端的响应之后，客户端也不会再发第三次握手了，所以不会建立多余连接。

5. 3次握手都有哪些用？
	* 确保连通性
	* 得知对方的初始序号
	* 商议 流量控制窗口 和 MSL 长度。
	
6. 为什么是四次挥手

   因为在主动断开方发送FIN，被动方发送ACK之后，被动方还有可能会发送数据，需要等被动方将剩余数据发送完之后，才能真正断开连接。

7. TCP如何保证可靠
   * 序号
   * ACK机制
   * 重传

8. 各个状态作用
	CLOSE WAIT https://huoding.com/2016/01/19/488
	TIME WAIT https://huoding.com/2013/12/31/316

