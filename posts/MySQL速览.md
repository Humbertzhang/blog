
<!-- TOC -->  
- [1. B树与B+树](#1-b树与b树)  
  - [1.1 B树](#11-b树)        
    - [1.1.1 定义：](#111-定义)    
    - [1.1.2 B树的查询操作](#112-b树的查询操作)  
    - [1.1.3 B树的插入操作](#113-b树的插入操作)      
    - [1.1.4 B树的删除操作](#114-b树的删除操作)     
  - [1.2 B+树](#12-b树)       
    - [1.2.1 B+树与B树的不同点：](#121-b树与b树的不同点)   
    - [1.2.2 B+树更适合数据库索引的原因](#122-b树更适合数据库索引的原因)
- [2. MySQL 索引](#2-mysql-索引)      
  - [2.1 B+树索引](#21-b树索引)     
  - [2.2 哈希索引](#22-哈希索引)     
  - [2.3 全文索引](#23-全文索引)     
  - [2.4 空间数据索引](#24-空间数据索引)   
  - [2.5 索引优化](#25-索引优化)         
    - [2.5.1 索引列独立使用](#251-索引列独立使用)   
    - [2.5.2 多列索引](#252-多列索引)        
    - [2.5.3 关于MySQL中复合索引的顺序问题](#253-关于mysql中复合索引的顺序问题)  
    - [2.5.4 前缀索引](#254-前缀索引)        
    - [2.5.5 覆盖查询的索引](#255-覆盖查询的索引)     
  - [2.6 索引优点](#26-索引优点)      
  - [2.7 索引使用条件](#27-索引使用条件)
- [3.查询性能优化](#3查询性能优化)   
  - [3.1 使用 Explain 进行分析](#31-使用-explain-进行分析)  
  - [3.2 优化数据访问](#32-优化数据访问)         
    - [3.2.1 减少请求的数据量](#321-减少请求的数据量)        
    - [3.2.2 减少服务端扫描的行数](#322-减少服务端扫描的行数)    
  - [3.3 重构查询方式](#33-重构查询方式)      
    - [3.3.1 切分大查询](#331-切分大查询)    
    - [3.3.2 分解大连接查询](#332-分解大连接查询)
- [4.存储引擎比较](#4存储引擎比较)      
  - [4.1 InnoDB](#41-innodb)      
  - [4.2 MyISAM](#42-myisam)      
  - [4.3 比较](#43-比较)
- [5.切分](#5切分)     
  - [5.1水平切分](#51水平切分)       
    - [5.1.1 Sharding 策略](#511-sharding-策略)      
    - [5.1.2 Sharding 存在的问题](#512-sharding-存在的问题)    
  - [5.2垂直切分](#52垂直切分)
- [6.主从复制与读写分离](#6主从复制与读写分离)   
  - [6.1 主从复制](#61-主从复制)     
  - [6.2 读写分离](#62-读写分离)     
    - [6.2.1 介绍：](#621-介绍)      
    - [6.2.2 读写分离优点：](#622-读写分离优点)    
    - [6.2.3 实现：](#623-实现) 
<!-- /TOC -->

# 1. B树与B+树

### 1.1 B树

概览：B树是一个多叉平衡查找树。

为什么用多叉树？

传统的二叉查找树结构**由于树的深度过大而造成磁盘I/O读写过于频繁**，从而导致查询效率低下，因此应该降低树的深度，从而减少磁盘查找存取的次数。所以，一个基本的想法就是：采用多叉树结构（增加一个结点的元素个数）。



#### 1.1.1 定义：

一棵m阶的B树定义如下：

1. **儿子结点个数**角度：

   任意非叶子节点最多只有m个儿子结点，且m>2，有：

   - 根结点的儿子结点数为[2, m]，除非B树只有根结点这一个结点。

   - 除根结点之外的非叶子结点的儿子结点数为 [m/2向上取整， m] 个节点。
   - 叶子结点没有儿子（废话！）

2. **结点内部关键字个数**角度：

   非叶子结点的关键字个数 = 儿子结点数-1； 

   叶子结点的关键字个数n满足：**m/2向上取整减1** <=  N  <=  **m-1**.

3. 所有叶子结点位于同一层。

4. 在每个结点内部，k个关键字将结点拆分成k+1段，每段存放一个指针，分别指向k+1个子结点，同时满足查找树的大小关系（左小右大），注意叶子结点不指向子结点。



有关B树的一些需要注意的特性：

- 关键字集合分布在**整棵树**上。
- 任何一个关键字出现且只出现在一个结点中。
- 搜索有可能在非叶子结点结束。
- B树的搜索性能等价于在整个关键字集合中做一次二分查找。



#### 1.1.2 B树的查询操作

![](https://ae01.alicdn.com/kf/HTB1AZzWOyLaK1RjSZFxq6ymPFXa7.jpg)

从上图B树中找到E字母，流程如下：

1. 获取根结点的关键字进行比较。因为E<M，所以继续在左子树上找。

2. 拿到关键字D和G，因为D<E<G，所以直接找到D和G中间的结点。

3. 拿到E和F，发现E等于E，之间返回关键字和指针信息。

   如果找不到会直接返回NULL。



#### 1.1.3 B树的插入操作

对一棵高度为h的m阶B树，插入一个元素时，首先看元素在B树中是否存在，如果不存在，那么就去查找到相应的叶子结点之后进行插入。

插入时树的操作分三种情况：

- 如果叶子结点空间足够，即叶子结点的关键字个数小于m-1，则直接插入到叶子结点的相应位置。
- 如果叶子结点空间满了，那么就插入之后，将该节点分裂。
  - 将中间的关键字元素上移到父结点上。
  - 将一半的关键字元素分裂到其相邻的，新创建的右节点上。
  - 相应的父子结点的指针也会随之变动。
- 如果在上述移动过程中，导致父结点满了，那么需要递归地进行该过程。如果根结点也满了，则也进行分裂操作，并将树的高度增加一层。



#### 1.1.4 B树的删除操作

在删除时，也是先找到删除的结点的位置，然后删除它。

删除该元素后，需要判断该元素是否有左右子结点：

- 有，则上移孩子结点中相近元素（左孩子最右结点或右孩子最左结点）到父结点中。
- 如果没有，则直接删除。
- 如果父结点不满足B树子结点个数的要求的话，则分情况有一下操作：
  - 父结点先看其他子结点是否有多余，有则父结点下去，其他孩子结点中相近元素上移到父结点。
  - 如果没多余，则父结点会先合并子结点，之后和自己的父结点进行合并与重整。
- 如果删除后本结点不满足关键字个数要求，则看其兄弟结点是否丰满（减少一个结点是否还满足B树要求）
  - 如果丰满，则向父结点借一个元素来满足。父结点不满足时从丰满结点借一个元素。
  - 如果都不丰满，则该节点与其一个兄弟结点进行合并。



关于删除的例子可见：https://www.jianshu.com/p/db226e0196b4





### 1.2 B+树

![](https://ae01.alicdn.com/kf/HTB12MJxOHvpK1RjSZFqq6AXUVXak.jpg)

#### 1.2.1 B+树与B树的不同点：

- 所有叶子节点包含**全部关键字信息**以及**指向含有这些关键字记录的指针**，且叶子节点中关键字进行有序**链接**。 
- 非叶子节点相当于是叶子节点的索引（而不像B树一样还存储元素信息）叶子节点相当于是存储（关键字）数据的数据层。



#### 1.2.2 B+树更适合数据库索引的原因

- B+树的磁盘读写代价更低。B+树的非叶子结点上没有指向具体信息的指针，因此一个磁盘页可以容纳更多的结点元素。
- 对于范围查找来说，B+树只需要遍历叶子结点的链表即可，而B树则需要重复地进行树的遍历。



# 2. MySQL 索引

索引是在MySQL的存储引擎层实现的，而不是在服务器层实现的。不同的存储引擎有不同的索引类型与实现。

### 2.1 B+树索引

大多数MySQL的默认索引类型为B+树索引。用树进行搜索，不需要进行全表扫描，所以查找速度快很多。

B+树索引的一些属性：

- B+树索引除了用于查找，还可以用于排序和分组。

- 可指定多个列作为索引列，多个索引列共同组成键，成为复合索引或组合索引。
- 适用于 全键值(=)、键值范围（大于、小于）和键前缀（like?）查找。其中键前缀查找只适用于最左前缀查找。
- 关于**组合索引的使用顺序**问题见2.5节。



innoDB 的B+树索引分为主索引和辅助索引。

- **主索引**的叶子结点data域记录着一条数据记录本身，这种索引方式被称为**聚簇索引**。因为无法将数据放在两个不同的地方，因此一个表只能有一个聚簇索引。
- **辅助索引**的叶子结点的data域记录着主键的值，因此在使用辅助索引查找时，需要先使用辅助索引找到相应的主键值，之后再使用主索引进行查找。



### 2.2 哈希索引

哈希索引能以O(1)的时间进行查找，但是失去了B+树有序的性质。

导致：

- 无法用于排序和分组
- 只支持精确查找，无法用于部分查找

InnoDB在当某个索引值被非常频繁得使用时，会自己在B+树之上再创建一个哈希索引，让数据库可以快速查找到这个值。



### 2.3 全文索引

MyISAM存储引擎支持全文索引，用于查找文本中的关键词，innoDB存储在MySQL5.6.4版本后也开始支持全文索引。

查找条件使用MATCH AGAINEST，而不是普通的WHERE。

全文索引使用**倒排索引**实现，记录**从关键词到其完成数据的映射**。



### 2.4 空间数据索引

MyISAM存储引擎支持空间数据库索引（使用R-Tree），可用于地理数据的存储。





### 2.5 索引优化

#### 2.5.1 索引列独立使用

在进行查询时，索引列不能是表达式(`如cid+1=5`)的一部分，也不能是函数的参数，否则索引无法生效。



#### 2.5.2 多列索引

在需要使用多个列作为条件进行查询时，使用**多列索引**（复合索引）比使用多个单列索引性能更好。

```SQL
SELECT name, cid from student where name="humber" AND cid=1;
```

在上面语句中，就最好将name, cid设为多列索引而不是设为多个单索引。



#### 2.5.3 关于MySQL中复合索引的顺序问题

```sql
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `cid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `name_cid_INX` (`name`,`cid`),
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8
```

对name, cid进行复合索引，如图所示。

![](https://ae01.alicdn.com/kf/HTB1O6VCOSzqK1RjSZFHq6z3CpXat.jpg)

在这里MySQL会先对复合索引的最左边，也就是对第一个name字段数据进行排序，在第一个字段排序的基础上，然后再对后面第二个cid进行排序。

所以，name字段是绝对有序的，而第二个字段就是无序的了。所以通常直接使用第二个字段进行条件判断就是用不到索引的了。

要想使用这个索引，一定要是在name为等值匹配的情况下(也就是`name=myname`这种匹配)，cid才是有序的。

这也就是说，**MySQL中要求使用复合索引时，要想使用到第二个索引，就必须先使用第一个索引，并且第一个索引必须是等值匹配**。



#### 2.5.4 前缀索引

对于 BLOB，TEXT，VARCHAR等类型的列，必须使用前缀索引，只索引开始的部分字符。



#### 2.5.5 覆盖查询的索引

含义：索引中包含有所有需要查询的字段的值，即SELECT后面的属性列都被包含在索引中了。

优点：

- 大大减少数据的访问量
- 对于InnoDB，若辅助索引可以覆盖查询，则无需访问主索引
- 对于MyISAM，在内存中只缓存索引，而数据则依赖于操作系统来缓存（需要系统调用来使用）。因此只访问索引可以不使用系统调用，减少耗时。



### 2.6 索引优点

- 大大减少了服务器需要扫描的数据行数。

- 帮助服务器避免进行排序和分组（B+Tree支持排序`order by`、分组`group by`)。

  因此可以避免创建临时表（临时表主要是在排序和分组中创建，因此也减少了创建临时表的情况）

- 将随机I/O改为了顺序I/O （B+Tree索引是有序的，会将相邻的数据存储在一起）。



### 2.7 索引使用条件

- 对于很小的表，大部分情况下简单的全表嫂面比建立索引更高效。
- 对中大型表，索引非常有效。
- 对特大型的表，建立和维护索引的代价也随之增长。



# 3.查询性能优化



### 3.1 使用 Explain 进行分析

Explain可以用来分析SELECT查询语句，开发人员可以通过分析Explain结果来优化查询语句。

重要字段：

- select_type: 查询类型，包括简单查询、联合查询、子查询等
- key: 使用的索引
- rows：扫描的行数



### 3.2 优化数据访问

#### 3.2.1 减少请求的数据量

- 只返回必要的列，而不是直接使用select * 。
- 只返回必要的行，使用LIMIT来限制返回的数据。
- 缓存被重复查询的数据。



#### 3.2.2 减少服务端扫描的行数

使用索引来覆盖查询。



### 3.3 重构查询方式



#### 3.3.1 切分大查询

将一个一次性请求很多数据的查询切分成多次小查询。

一次性使用一个大查询的话，可能一次锁很多数据，耗尽系统资源，阻塞很多小但是重要的查询。



#### 3.3.2 分解大连接查询

将一个大连接查询分解成对每个表进行一次单表查询，然后在应用程序中进行关联。

好处：

- 让缓存更高效。

  对于连接查询，如果其中一个表发生了变化，那么整个查询的缓存都不可用了。

  而分解成多个查询后，即使其中一个表发生变化，其他表的缓存依然可以使用。

  并且分解为多个单表查询，这些缓存结果更容易被其他查询使用到，从而减少冗余记录的查询。

- 减少锁竞争。

- 在应用层进行连接，可以更容易对数据库进行拆分。




# 4.存储引擎比较



### 4.1 InnoDB 

pronounce `inno DB`

MySQL的**默认**事务型存储引擎。

特性：

- 设计较为复杂。

- 支持事务

- 实现了事务的四个标准隔离级别。默认为可重复读。

  在可重复读的隔离级别下，通过多版本并发控制[MVCC] + 间隙锁 来防治幻影读。

- 主索引为聚簇索引。在索引中保存了数据，从而避免了直接读取磁盘，对查询效率提升很大。

- 支持行级加锁。

- 内部做了很多优化：可预测读、自适应哈希、插入缓冲区等等。

- 支持真正的在线热备份。（其他存储引擎不支持，因此在备份时会导致停止所有的写入）





### 4.2 MyISAM 

pronounce` My I Sam`

- 设计简单。

- 不支持事务。

- 不支持行级加锁，只能对整张表加锁。但是在表有读取操作同时，也可以向其中插入新数据。

- 可以手动或自动执行检查和修复操作，但是可能导致数据丢失，且错误修复较慢。

- 提供大量特性：压缩表、空间数据索引等。

- 如果指定了 `DELAY_KEY_WRITE` 选项，那么每次修改完成时，不会立即将修改的索引数据写入磁盘，而是写入到内存中的缓冲区。只有清理键缓冲区或关闭表时才会将对应的索引块写入磁盘。

  这种方式可以极大提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏。



### 4.3 比较

- 事务：InnoDB支持事务型，MyISAM不支持事务。
- 并发：InnoDB支持行级锁和表级锁，MyISAM只支持表级锁。
- 外键：InnoDB支持外键，而MyISAM不支持
- 备份：InnoDB支持在线热备份，MyISAM不可。
- 崩溃恢复：MyISAM发生崩溃后发生损坏的概率比InnoDB高很多，且恢复速度也更慢。
- 其他特性：MyISAM支持 `压缩表` 和 `空间数据索引`。



# 5.切分

### 5.1水平切分

水平切分又称Sharding，是将同一个表中记录拆分到多个结构相似的表中。

当一个表中数据不断增多时，必然要选择Sharding，它可以将数据分布到集群的不同节点上，来缓解单个数据库的压力。

#### 5.1.1 Sharding 策略

- 哈希取模： hash(key) % N
- 范围: 按ID范围或时间范围等等
- 映射表：用单独的一个数据库来存映射关系。

#### 5.1.2 Sharding 存在的问题

- 事务问题

  使用分布式事务来解决，如使用XA协议。

  XA协议分为两个阶段：

  第一阶段：事务管理器要求每个涉及到事务的数据库**预提交**此操作，并反馈是否可以提交。

  第二阶段：事务协调器要求每个数据库提交数据或回滚数据。

  **优点**：尽量保证了数据的强一致性，实现成本比较低。

  **缺点**：

  - **事务管理器宕机**时可能造成问题。
  - **不支持高并发**，因为其为同步阻塞的。
  - **数据还是有可能不一致**。

- 表的连接问题

  将原来的连接查询分解为多个单表查询，在用户程序中进行连接。

- ID唯一性问题

  - 使用全局唯一ID （GUID也称UUID）：使用网卡的MAC地址再结合时间信息。

  - 为每个数据库执行一个ID范围

  - 分布式ID生成器（如twitter的Snowflake算法）

    ```
    snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。
    其核心思想是：
    使用41bit作为毫秒数
    10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID）
    12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）
    最后还有一个符号位，永远是0。
    ```

    ![](https://ae01.alicdn.com/kf/HTB1RQSnONnaK1RjSZFtq6zC2VXap.jpg)


### 5.2垂直切分

将一个表按列切分成多个表，通常按照列的关系紧密程度，或者按照是否经常使用来切分。





# 6.主从复制与读写分离



### 6.1 主从复制

主从复制涉及三个线程：binlog线程、I/O线程和SQL线程

- 【主】binlog线程：负责将主服务器上的数据更改写入二进制日志(Binary log)中。
- 【从】I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中(Relay log)。
- 【从】SQL线程：负责读取中继日志，解析出主服务器已经执行了的数据更改，并在从服务器上运行。

![img](https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/master-slave.png)





### 6.2 读写分离

#### 6.2.1 介绍：

主服务器：处理写操作和实时性要求较高的读操作。

从服务器：处理读操作。



#### 6.2.2 读写分离优点：

- 主从服务器各自负责各自的读写，**缓解了锁的争用**。
- 从服务器可以使用MyISAM，可以提升查询性能，节约系统开销。
- 增加冗余，提升整个数据库系统的可靠性。



#### 6.2.3 实现：

读写分离常使用代理的方式来实现，代理服务器接受应用层的读写请求，然后决定转发给哪个服务器。

![img](https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/master-slave-proxy.png)







参考:

分布式事务：https://juejin.im/post/5b5a0bf9f265da0f6523913b

https://blog.csdn.net/login_sonata/article/details/75268075

https://www.jianshu.com/p/db226e0196b4



