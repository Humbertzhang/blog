目录：
<!-- TOC -->

- [HTTP](#http)
    - [一、请求和相应报文](#一请求和相应报文)
    - [二、HTTP Methods](#二http-methods)
    - [三、HTTP 状态码](#三http-状态码)
        - [1XX： 信息性状态码 表示接受的请求正在处理](#1xx-信息性状态码-表示接受的请求正在处理)
        - [2XX：成功状态码 请求正常处理完毕](#2xx成功状态码-请求正常处理完毕)
        - [3XX 重定向](#3xx-重定向)
        - [4XX 客户端错误](#4xx-客户端错误)
        - [5XX 服务器错误](#5xx-服务器错误)
    - [四、HTTP 技术细节](#四http-技术细节)
        - [1.连接管理](#1连接管理)
        - [2.Cookie](#2cookie)
        - [3.缓存](#3缓存)
        - [4.内容编码（压缩）](#4内容编码压缩)
        - [5.通信数据转发](#5通信数据转发)
    - [五、HTTP/1.1特性](#五http11特性)
    - [六、HTTP/2.0新特性](#六http20新特性)
        - [1. 二进制分帧层](#1-二进制分帧层)
        - [2. 请求与响应复用](#2-请求与响应复用)
        - [3.数据流优先级](#3数据流优先级)
        - [4.每个来源一个连接](#4每个来源一个连接)
        - [5.流控制](#5流控制)
        - [6.服务器推送](#6服务器推送)
        - [7.标头压缩](#7标头压缩)
    - [七、GET POST比较](#七get-post比较)
- [HTTPS](#https)
    - [1.HTTPS的基本思想](#1https的基本思想)
    - [2.数字证书签发过程](#2数字证书签发过程)
    - [3. HTTPS的建立:四次握手](#3-https的建立四次握手)
        - [第一次握手](#第一次握手)
        - [第二次握手](#第二次握手)
        - [第三次握手](#第三次握手)
        - [第四次握手](#第四次握手)
    - [4.HTTPS中间人攻击](#4https中间人攻击)
        - [4.1 SSL证书欺骗攻击](#41-ssl证书欺骗攻击)
        - [4.2 SSL剥离攻击](#42-ssl剥离攻击)
    - [5. HTTPS常见问题](#5-https常见问题)

<!-- /TOC -->



# HTTP



### 一、请求和相应报文

请求报文：

```http
GET /doc/doc1.html HTTP/1.1			// 方法 资源 版本信息
Header1: Value						// Headers
Header2: Value
									// 一个空行 \r\n
bookid=123&author=humber 			// Request Body
```

响应报文

```http
HTTP/1.1 200 OK 					// 版本信息，状态码
Header1: Value						// Headers
Header1: Value
									// 空行 /r/n
<h1> Hello </h1> 					// Response Body
```



### 二、HTTP Methods

GET: 获取资源

POST： 传输实体主体

PUT：上传、修改资源

DELETE：删除资源

HEAD：获取报文首部，和GET类似，但是不返回资源实体

PATCH：部分修改资源

OPTIONS：查询支持的方法

CONNECT：使用SSL和TLS协议将通信内容加密后经网络隧道传输

TRACE：服务器会将通信路径返回给客户端



### 三、HTTP 状态码

#### 1XX： 信息性状态码 表示接受的请求正在处理

100 Continue: 表明到目前为止正常，客户端可以忽略此响应.

#### 2XX：成功状态码 请求正常处理完毕

200 OK

201 Ceated: 创建成功

204 No Content: 请求成功，但返回的响应报文不包含实体主体部分

206 Partial Content: 客户端进行了部分请求，相应报文包含部分实体内容

#### 3XX 重定向

301 Moved Permanently: 永久重定向

302 Found: 临时性重定向

303 See Other: 类似302，但是明确要求客户端应使用GET获取资源

（大多数浏览器都会将在301、302、303 下的重定向中将POST便为GET）

304 Not Modifed: 客户端请求报文中包含对资源实效性的检测条件，如果资源仍有效则服务端返回304

307 Temporary Redirect: 临时重定向，且无需将POST改为GET.

#### 4XX 客户端错误

400 Bad Request: 请求报文中有语法错误。

401 Unanthorized: 无认证信息或认证失败。

403 Forbidden: 请求被拒绝

404 Not Found

405 Method Not Allow

#### 5XX 服务器错误

500 Internal Server Error: 服务器执行请求时发生错误

503 Service Unavailable: 服务器无法处理请求

504 Timeout: 超时



### 四、HTTP 技术细节

#### 1.连接管理

1⃣️ 短连接与长链接

短连接：每次请求一个资源便新建一个TCP连接

长连接：只需建立一次TCP连接，进行多次HTTP通信。

长连接：Conntection: Keep-Alive;

关闭连接：Connection: close; 

2⃣️流水线

默认情况下，HTTP只有在前一个请求收到响应之后才会发出下一个请求。在流水线模式下，HTTP在同一条长连接上发出连续请求，而不需要等待响应返回，以此避免连接延迟。



#### 2.Cookie

Cookie时服务器发送到浏览器并被浏览器保存的一段数据。他会在浏览器接下来的请求中被带上，用于标示用户身份。

主要用途： 

- 会话状态管理
- 浏览器行为跟踪
- 用户身份标示 等

1⃣️创建过程

服务端返回Set-Cookie首部字段，客户端得到响应后将Cookie放到浏览器中。

2⃣️分类

会话期Cookie：浏览器关闭后被自动删除.

持久性Cookie: 在 一个过期时间之前(Expires) 或 有效期之内（max-age）都有效，即为一个持久性的Cookie.

如下:

```http
Set-Cookie: id=abcDDe; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

3⃣️ Cookie的作用域

Domain 指定了那些主机可以接受此Cookie，如不指定则为当前主机。如指定了，则一般对其子域名也有效。

Path标识 指定了主机下哪些路径可以接受Cookie. 

4⃣️ HttpOnly

标记为HttpOnly的Cookie不能被JavaScript脚本调用，以此来在一定程度上避免 跨站脚本攻击（XSS）。

5⃣️ Secure

标记为Secure的Cookie只能被HTTPS加密过后的请求发给服务端。

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

6⃣️ Session

将用户信息用Session存储在服务端。

其在用户登录的时候产生一个 Session ID，并在服务器存储中，将Session ID 作为Key，用户信息作为 Value，因此比Cookie更安全。

但是一旦Session ID 被窃取了之后，也会有安全性问题。 常用的预防方式为：经常性重新生成Session ID， 在安全性要求很高的情况下让用户再次输入密码 等。



#### 3.缓存

1⃣️ 优点

- 缓解服务器压力。
- 降低客户端获取资源延迟

2⃣️ 实现

- 代理服务器缓存
- 客户端浏览器进行缓存

3⃣️ HTTP 通过Cache-Control 来控制缓存

- 禁止缓存

  Cache-Control: no-store

- 强制确认缓存，即规定缓存服务器先确认缓存资源的有效性，有效时才对客户端请求进行响应。

  Cache-Control: no-cache

- 私有缓存、公共缓存。 私有缓存一般存在用户浏览器中，供单个用户使用；而公共缓存规定资源作为公共缓存，可被多个用户使用，一般在代理服务器中。

  Cache-Control: private

  Cache-Control: public

- 缓存过期机制

  - max-age: 指定缓存资源在服务器中保存的时间

    Cache-Control: max-age:31536000

  - Expires:指定缓存什么时候过期

    Expires: Wed, 04 Jul 2012 08:26:05 GMT

4⃣️ **缓存验证** 

- ETag + If-None-Match 方案

ETag首部字段：资源的唯一标识。URL不能唯一标识一个资源。如一个URL可能有多个语言版本。此时需要用ETag来对两个资源进行唯一标识。 ETag的值的生成需要后台使用一个Hash算法算出来。

浏览器使用时，将ETag的值放入 `If-None-Match`首部，服务器收到请求后先判断之前的资源是否还有效，有效则返回304，让浏览器直接使用缓存的资源即可。

- Last-Modified + If-Modified-Since方案

Last-Modied首部也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间，但是因为只精确到秒，并不能完全保证没有修改。 常作为ETag的备用方案。

当客户端请求时，在后续的请求上带上 `If-Modified-Since`配合Last-Modified的时间一起来验证缓存。如果请求的资源未修改，那么返回一个不带消息主体的304 Not Modified 响应。



#### 4.内容编码（压缩）

浏览器请求时发送 `Accept-Encoding` 首部，指示其接受的压缩算法和优先级，服务器从中选择一种将资源压缩，并用 Content-Encoding 来告知浏览器他的选择。



#### 5.通信数据转发

1⃣️ 代理

使用代理的目的：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

正向代理： 用户可以察觉到代理存在。

反向代理：用户察觉不到代理存在。

2⃣️ 网关

网关将HTTP请求转化为其他协议通信，从而可以请求非HTTP服务器的服务。

3⃣️ 隧道

使用TLS等加密手段，在客户端和服务端之间建立一条安全的通道。



### 五、HTTP/1.1特性

- 默认长连接
- 支持流水线
- 支持同时打开多个TCP连接
- 支持虚拟主机
- 新增状态码100
- 支持分块传输编码
- 新增缓存处理指令max-age



### 六、HTTP/2.0新特性

HTTP/1.X的实现简单，但性能不好。 HTTP/1.X 缺陷如下：

- 客户端需要使用多个TCP连接才能实现并发
- 不压缩请求和响应首部，导致了不必要的网络流量
- 不支持资源优先级，导致TCP连接的利用率低下

#### 1. 二进制分帧层 

**HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。**

![img](https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/86e6a91d-a285-447a-9345-c5484b8d0c47.png)



**在通信过程中，只会有一个TCP连接存在，它可以承载任意数量的双向数据流(Stream)。**



![img](https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/af198da1-2480-4043-b07f-a3b91a88b815.png)



上图中有Stream、Message、Frame 共三个实体，三个实体的解释如下：

- 数据流（Stream）： 已建立的（TCP）连接内的双向字节流，可承载一条或多条消息（Message）.

- 消息（Message）: 与逻辑请求或相应请求对应的一系列帧（Frame），即一个信息为原来一次请求或响应对应的一个HTTP报文，包括Header和DATA。

- 帧（Frame）：HTTP/2通信的最小段位，每个帧包含帧头，标识出当前帧所属的数据流。

这三个实体之间的关系如下：

- 所有通讯都在一个TCP连接上完成，此TCP连接可承载任意数量的双向数据流。
- 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。
- 每条消息都是一个逻辑上的HTTP消息（请求或响应都可），包含一个或多个帧。
- 帧是HTTP/2的最小通信单位，承载特定类型的数据（HTTP 标头、消息负载等）。来自不同数据流的帧可以**交错发送**，之后再根据每个帧头的数据流标识符重新组装。



[HTTP/2.0 TODO](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn#_2)



#### 2. 请求与响应复用

#### 3.数据流优先级

#### 4.每个来源一个连接

#### 5.流控制

#### 6.服务器推送

#### 7.标头压缩



### 七、GET POST比较

1. **作用**的区别

   GET 用于获取资源。

   POST用于传输实体主体。

2. **参数**的区别

   GET的参数存在URL中，只支持ASCII码，其他文字需要进行编码。

   POST的参数存在Body中，支持标准字符集。

3. **安全性**上的区别

   何谓安全的HTTP方法：不改变服务器状态。

   GET是安全的HTTP方法，POST不是安全的。

   安全的HTTP方法还包括：HEAD OPTIONS

   不安全的还有：PUT DELETE 

4. **幂等性**上的区别

   幂等性指：同样的请求执行一次与执行多次效果一样，服务器状态也一样。

   正确情况下，GET、PUT、DELETE、HEAD等方法都是幂等的，而POST不是幂等的。

5. **响应可缓存**上的区别

   此处指对响应进行缓存。

   GET一般可缓存，但POST一般不可缓存。

6. XMLHttpRequest 



# HTTPS

HTTP的问题：

- 明文通信，不安全
- 不验证通信方身份，可能遭遇伪装
- 无法验证报文完整性

解决方案：使用HTTPS，即使用SSL/TLS对HTTP进行加密。



### 1.HTTPS的基本思想

- 用非对称加密算法 得出 对称加密算法的密钥。
- 之后使用对称加密的方式来对HTTP请求进行加密

（因为非对称加密比对称加密的运算量高太多，完全使用非对称加密会很慢，很占用资源）



### 2.数字证书签发过程

数字证书由认证机构CA来颁发，其为客户端和服务端都认可的第三方机构。

签发步骤：

1. 服务端自己生成私钥，再根据私钥生成公钥。

```bash
# 生成私钥
openssl genrsa -out cliu8siteprivate.key 1024
# 生成公钥
openssl rsa -in cliu8siteprivate.key -pubout -outcliu8sitepublic.pem
```

1. 服务端向CA提供申请信息(域名等信息)和公钥。

1. CA 将 申请信息+公钥 做Hash运算，得到一串字符串，在用**CA自己的私钥**来对其进行加密（非对称加密），得到最终的**数字签名**。CA将数字签名、服务端提供的私钥填在其颁发给该服务器的证书中，再发给服务端。



### 3. HTTPS的建立:四次握手

![](https://static001.infoq.cn/resource/image/12/f3/122d0865731c1ce3e109dfad4a193ef3.png)



#### 第一次握手

客户端发送：

- 生成的**随机数1**
- 客户端可接受的加密方式



#### 第二次握手

服务端接到客户端第一次握手请求后，发送第二次握手。

服务端发送：

- 生成的**随机数2**
- 服务端选择的加密方式
- CA颁发的证书（其上有公钥和数字签名）



#### 第三次握手

客户端接到服务端发送的第二次握手后，首先验证证书。

**验证证书过程：**

1. 先查看携带的信息是否与服务端相匹配。
2. 从客户端信任的CA库中，拿到相应的**CA的公钥**，对**证书中的数字签名**进行解密，得到Hash值。
3. 对证书中携带的信息和公钥再进行一次Hash，用得到的Hash值同第二步中的值比较，若相同则代表证书中信息没有被篡改。

之后客户端发送**第三次握手**信息：

- 生成**随机数3**，并用证书中的公钥对其进行加密。



#### 第四次握手

服务端收到了第三次握手中的加密后的**随机数3**后，用自己的私钥进行解密。此时，客户端与服务端都拥有三个随机数，他们用前**两次握手协商得到的加密方式和三个随机数**一起算出**对称密钥**。

服务端发送第四次握手：

告知客户端之后便用对称密钥对通信内容进行**对称加密**了。



此后双方的HTTP通讯便使用对称密钥进行对称加密来保护。



### 4.HTTPS中间人攻击



#### 4.1 SSL证书欺骗攻击

这种SSL中间人攻击，攻击者和靶机，攻击者和服务器之间都是建立的HTTPS可信链接，只是通过openssl生成自签名的证书，利用用户不仔细查看证书的不小心，来进行证书劫持。

#### 4.2 SSL剥离攻击

中间人攻击者在劫持了客户端与服务端的HTTP会话后，将HTTP页面里面所有的`https://`超链接都换成`http://`，用户在点击相应的链接时，是使用HTTP协议来进行访问；这样，就算服务器对相应的URL只支持HTTPS链接，但中间人一样可以和服务建立HTTPS连接之后，将数据使用HTTP协议转发给客户端，实现会话劫持。



### 5. HTTPS常见问题

- **随机数为什么要三个？**
  这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。

- 涉及到的算法

  非对称加密算法：RSA，DSA/DSS
  对称加密算法：AES，RC4，3DES
  HASH算法：MD5，SHA1，SHA256






Refs:

- https://www.infoq.cn/article/bZTED-LPHd1JVQqFk2ql
- http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html
- https://www.baidu.com/sf_bk/item/ca证书/10028741?fr=aladdin&ms=1&rid=9627370440075920029
- https://cyc2018.github.io/CS-Notes/#/notes/HTTP?id=%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA
- HTTP2.0: https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn#_2 




